import java.io.*;

/**
 * This is a test file that investigates the recursion limit of arrays of various sizes.
 * It investigate all recursion limits from 2 to 300 in steps of 2.
 *
 * @author Veronika Cabalova Joseph
 */

public class TestFileForRecursionLimit {

    // -------  main --------------
    public static void main(String[] args)
    {
        final int MIN_RECURSION_LIMIT = 2;
        final int ARRAY_SIZE = 20000;
        final int LARGEST_ARRAY_SIZE = 10000000;
        final int INCREMENT_ARRAY_SIZE_AMOUNT = 499000;

        int recursionCount;

        // set recursion limit to minimum limit (2) to start
        recursionCount = MIN_RECURSION_LIMIT;

        // loop to grow the array size up, each loop pass, up to 10M
        for (int j = ARRAY_SIZE; j < LARGEST_ARRAY_SIZE; j += INCREMENT_ARRAY_SIZE_AMOUNT)
        {
            System.out.println("\n\n============= Quick Sort for"
                    + " Array Size: " + j + " =============\n");

            Integer[] arrayOfInts = new Integer[j];

            // generate array of random ints
            for (int i = 0; i < j; i++)
            {
                arrayOfInts[i] = (int) (Math.random() * j);
            }

            // run recurseAndTimeArray method to recurse through each recursion limit and time it,
            // save time result in a string so it can be used in CSV file
            String addNextTimeResult = recurseAndTimeArray(recursionCount, arrayOfInts);

            // make csv file from run result
            createCSVFile(j, addNextTimeResult);
        }
    }


// ================================== Helper Methods ==================================

    /**
     * helper method that creates CSV files every time array size changes
     * and prints result of string that is generated by recureseAndTimeArray
     * into the CSV file for each recursion limit value
     * @param arraySize int size of array
     * @param nextResultRow string that holds recursion limit value and elapsed time value
     */
    public static void createCSVFile(int arraySize, String nextResultRow)
    {
        // write the print result into csv file
        PrintWriter printWriter = null;

        try
        {
            // create CSV file for reach array size
            printWriter = new PrintWriter(new File("resources/array" + arraySize + ".CSV"));

            printWriter.print(nextResultRow);
            printWriter.close();

            System.out.println("Done");
        }
        catch (FileNotFoundException e)
        {
            System.out.println("Warning: File was not found.");
        }
    }

    /**
     * helper method uses while loop to loop through various limits of recursion
     * between 2 and 300, it measures the time, of quick sort, each recursion limit
     * takes using helper method timeTheQuickSort
     * @param recursionCount of type integer, recursion limit value
     * @param arrayOfInts array that holds random generated integers
     * @return String that holds recursion count and the elapsed time value
     */
    public static String recurseAndTimeArray(int recursionCount, Integer[] arrayOfInts)
    {
        int maxRecursionLimit = 300;
        Integer[] toSortArray;

        //time measuring vars
        String topTitleRow = "Recursion Count, Time";
        String addNextResult = topTitleRow + "\n";

        // within loop, recurse and time from 2 to 300 for each array size
        while (recursionCount <= maxRecursionLimit)
        {
            long elapsedTime = 0;
            final int SAMPLE_SIZE = 3;

            // loop to run quick sort on original array, copied three times and add up results for average
            for(int i = 0; i < SAMPLE_SIZE; i++)
            {
                // instantiate toSortArray with appropriate length
                toSortArray = new Integer[arrayOfInts.length];

                // copy the original array to preserve its random set of ints before sorting three times
                System.arraycopy(arrayOfInts, 0, toSortArray, 0, arrayOfInts.length);

                // add up all elapsed times into one
                elapsedTime += timeTheQuickSort(recursionCount, toSortArray);
            }

            // take average of 3 time estimates from same array and use that as time estimate
            long averageElapsedTime = (elapsedTime) / SAMPLE_SIZE;

            System.out.println("Recursions #: " + recursionCount
                    + "  |  Elapsed Time:   "
                    + TimeConverter.convertTimeToString(averageElapsedTime)
                    + " = " + averageElapsedTime + " ns");

            // fill in next row of csv file with time result and recursion count
            addNextResult += recursionCount + ","
                    + averageElapsedTime + "\n";

            // increase recursion by 2
            recursionCount += 2;
        }
        return addNextResult;
    }

    /**
     * helper method that times how long quick sort runs
     *
     * @param recursionCount of type integer, recursion limit value
     * @param toSortArray    array that holds random generated integers
     * @return estimated time of how long quick sort took
     */
    public static long timeTheQuickSort(int recursionCount, Integer[] toSortArray)
    {
        //time measuring vars
        long startTime;
        long estimatedTime;

        // ----------- start time -----------
        startTime = System.nanoTime();

        //sets number of recursions
        FHsort.setRecursionLimit(recursionCount);

        FHsort.quickSort(toSortArray);

        // ----------- stop time ------------
        estimatedTime = System.nanoTime() - startTime;

        return estimatedTime;
    }
}